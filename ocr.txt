!pip install reportlab 
import pypandoc
pypandoc.download_pandoc()
!pip install reportlab pymupdf
---------------
import os
import pytesseract
import fitz  # PyMuPDF
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import shutil
import time

import sys
print(sys.executable)
*********************************************************************************
from PyPDF2 import PdfReader
import re

# Chemin du fichier PDF
pdf_path = r"xx\data\\xxbnprte.pdf"

# Fonction pour extraire le texte du PDF
def extract_text_from_pdf(pdf_path):
    reader = PdfReader(pdf_path)
    text = ""
    for page in reader.pages:
        text += page.extract_text()
    return text

# Fonction pour extraire les informations avant et après "Faite nous confiance"
def extract_faite_nous_confiance(text):
    # Expression régulière pour capturer les lignes avant "Faite nous confiance", sans "Faite nous confiance"
    before_faite_match = re.search(r'(.*?)Faite nous confiance', text, re.DOTALL)
    if before_faite_match:
        before_faite_text = before_faite_match.group(1).strip()
    else:
        before_faite_text = "Aucune ligne trouvée avant 'Faite nous confiance'."

    # Expression régulière pour capturer les lignes à partir de "Faite nous confiance" jusqu'à "Message Text", en incluant "Faite nous confiance"
    after_faite_match = re.search(r'Faite nous confiance(.*?)Message Text', text, re.DOTALL)
    if after_faite_match:
        after_faite_text = after_faite_match.group(0).strip()  # group(0) inclut "Faite nous confiance"
    else:
        after_faite_text = "Aucune ligne trouvée entre 'Faite nous confiance' et 'Message Text'."

    return before_faite_text, after_faite_text


# Fonction pour extraire les 
def extract_lines_20_32A(text):
    line_20 = re.search(r'20:\s*Sender\'s Reference(.*?)(?=\n\d{2}[A-Z]:|$)', text, re.DOTALL)
    if line_20:
        line_20_text = line_20.group(0).strip()
    else:
        line_20_text = "Aucune ligne trouvée pour '20:'."

    line_32A = re.search(r'32A:\s*Val Dte/Curr/Interbnk Settld Amt(.*?)(?=\n\d{2}[A-Z]:|$)', text, re.DOTALL)
    if line_32A:
        line_32A_text = line_32A.group(0).strip()
    else:
        line_32A_text = "Aucune ligne trouvée pour '32A:'."

    return line_20_text, line_32A_text

# Fonction pour extraire les infos spécifiques de
def extract_info_72(text):
    text_cleaned = re.sub(r'\s+', ' ', text).strip()

    match_72A = re.search(r'ORxx\s*/(.*?)\/BExx', text_cleaned)
    if match_72A:
        info_72A = match_72A.group(1).strip()
    else:
        info_72A = "Aucune information trouvée entre 'ORxx/' et '/BExx/'."

    match_72B = re.search(r"/BExx/(.*?)\/FOR", text_cleaned)
    if match_72B:
        info_72B = match_72B.group(1).strip()
    else:
        info_72B = "Aucune information trouvée entre '/BExx/' et '/FOR'."

    return info_72A, info_72B

# Fonction pour extraire les informations après 'Message Trailer'
def extract_after_message_trailer(text):
    after_message_trailer = re.search(r'(Message Trailer.*)', text, re.DOTALL)
    if after_message_trailer:
        after_message_trailer_text = after_message_trailer.group(1).strip()
    else:
        after_message_trailer_text = "Aucune ligne trouvée après 'Message Traiter'."

    return after_message_traiter_text

# Extraction du texte
text = extract_text_from_pdf(pdf_path)

# Extraction des informations avant et après "Faite nous confiance"
before_faite_text, after_faite_text = extract_faite_nous_confiance(text)

# Extraction des lignes 20
line_20_text, line_32A_text = extract_lines_20_32A(text)

# Extraction des informations spécifiques pour 72A et 72B
info_72A, info_72B = extract_info_72(text)

# Extraction des informations
after_message_trailer_text = extract_after_message_trailer(text)

# Affichage des résultats
print("\nInformations avant 'Faite nous confiance':")
print(before_faite_text)
print(after_faite_text)
print(line_20_text)
print(line_32A_text)
print(f"72A(50 F): {info_72A}")
print(f"72B(59): {info_72B}")
print(after_message_traiter_text)

**********************************
from docx import Document
from docx.shared import Inches, Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
import pypandoc

word_output_path = r"extracted_data.docx"
pdf_output_path = r"extracted_data.pdf"

# Créer un nouveau document Word
doc = Document()

# Ajouter une section pour l'en-tête
header = doc.sections[0].header

# Créer un paragraphe pour le logo à gauche
header_paragraph_left = header.paragraphs[0]
header_run_left = header_paragraph_left.add_run()
logo_path = r"logo.png"
header_run_left.add_picture(logo_path, width=Inches(1.5))
header_paragraph_left.alignment = WD_PARAGRAPH_ALIGNMENT.LEFT  # Aligner le logo à gauche

# Ajouter un autre paragraphe pour le texte à droite
header_paragraph_right = header.add_paragraph()
header_paragraph_right.text = before_faite_text  # Assurez-vous que 'before_faite_text' est défini
header_paragraph_right.alignment = WD_PARAGRAPH_ALIGNMENT.RIGHT  # Aligner le texte à droite

# Ajouter le contenu principal dans le corps du document
doc.add_paragraph(after_faite_text)
doc.add_paragraph(line_20_text)
doc.add_paragraph(line_32A_text)
doc.add_paragraph(f"72A(50 F): {info_72A}")
doc.add_paragraph(f"72B(59): {info_72B}")

# Ajouter un pied de page
footer = doc.sections[0].footer
footer_paragraph = footer.paragraphs[0]
footer_paragraph.text = after_message_trailer_text

# Sauvegarder le document Word
doc.save(word_output_path)

# Convertir le document Word en PDF avec pypandoc
try:
    output = pypandoc.convert_file(word_output_path, 'pdf', outputfile=pdf_output_path)
    print(f"Document converti en PDF : {pdf_output_path}")
except Exception as e:
    print(f"Erreur lors de la conversion en PDF : {e}")

# Supprimer le fichier Word temporaire
try:
    #os.remove(word_output_path)
    print(f"Le fichier temporaire {word_output_path} a été supprimé.")
except Exception as e:
    print(f"Erreur lors de la suppression du fichier temporaire : {e}")

print(f"Le document a été généré et sauvegardé sous {pdf_output_path}")

---------------
import os
from PyPDF2 import PdfReader
import re
from docx import Document
from docx.shared import Inches, Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
import pypandoc

# Chemin du dossier contenant les fichiers PDF
pdf_directory = r"input"

# Chemin du dossier de sortie
output_directory = r"\output"

# Fonction pour extraire le texte du PDF
def extract_text_from_pdf(pdf_path):
    reader = PdfReader(pdf_path)
    text = ""
    for page in reader.pages:
        text += page.extract_text()
    return text

# Fonction pour extraire les informations avant et après "Faite nous confiance"
def extract_faite_nous_confiance(text):
    before_faite_match = re.search(r'(.*?)Faite nous confiance', text, re.DOTALL)
    if before_faite_match:
        before_faite_text = before_faite_match.group(1).strip()
    else:
        before_faite_text = "Aucune ligne trouvée avant 'Faite nous confiance'."

    after_faite_match = re.search(r'Faite nous confiance(.*?)Message Text', text, re.DOTALL)
    if after_faite_match:
        after_faite_text = after_faite_match.group(0).strip()
    else:
        after_faite_text = "Aucune ligne trouvée entre 'Faite nous confiance' et 'Message Text'."

    return before_faite_text, after_faite_text

# Fonction pour extraire les lignes 20 et 32A
def extract_lines_20_32A(text):
    line_20 = re.search(r'20:\s*Sender\'s Reference(.*?)(?=\n\d{2}[A-Z]:|$)', text, re.DOTALL)
    if line_20:
        line_20_text = line_20.group(0).strip()
    else:
        line_20_text = "Aucune ligne trouvée pour '20:'."

    line_32A = re.search(r'32A:\s*Val Dte/Curr/Interbnk Settld Amt(.*?)(?=\n\d{2}[A-Z]:|$)', text, re.DOTALL)
    if line_32A:
        line_32A_text = line_32A.group(0).strip()
    else:
        line_32A_text = "Aucune ligne trouvée pour '32A:'."

    return line_20_text, line_32A_text

# Fonction pour extraire les infos spécifiques de 72A et 72B
def extract_info_72(text):
    text_cleaned = re.sub(r'\s+', ' ', text).strip()

    match_72A = re.search(r'ORxx\s*/(.*?)\/BExx', text_cleaned)
    if match_72A:
        info_72A = match_72A.group(1).strip()
    else:
        info_72A = "Aucune information trouvée entre 'ORxx/' et '/BExx/'."

    match_72B = re.search(r"/BExx/(.*?)\/FOR", text_cleaned)
    if match_72B:
        info_72B = match_72B.group(1).strip()
    else:
        info_72B = "Aucune information trouvée entre '/BExx/' et '/FOR'."

    return info_72A, info_72B

# Fonction pour extraire les informations après 'Message Trailer'
def extract_after_message_trailer(text):
    after_message_trailer = re.search(r'(Message Trailer.*)', text, re.DOTALL)
    if after_message_trailer:
        after_message_trailer_text = after_message_trailer.group(1).strip()
    else:
        after_message_trailer_text = "Aucune ligne trouvée après 'Message Trailer'."

    return after_message_trailer_text

# Fonction principale pour traiter tous les fichiers PDF dans le dossier
def process_pdfs_in_directory(pdf_directory, output_directory):
    # Créer le répertoire de sortie s'il n'existe pas
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)

    # Parcourir tous les fichiers PDF dans le répertoire
    for filename in os.listdir(pdf_directory):
        if filename.endswith(".pdf"):
            pdf_path = os.path.join(pdf_directory, filename)
            print(f"Traitement du fichier : {filename}")
            
            # Extraction du texte du fichier PDF
            text = extract_text_from_pdf(pdf_path)
            
            # Extraction des informations spécifiques
            before_faite_text, after_faite_text = extract_faite_nous_confiance(text)
            line_20_text, line_32A_text = extract_lines_20_32A(text)
            info_72A, info_72B = extract_info_72(text)
            after_message_trailer_text = extract_after_message_trailer(text)
            
            # Créer un nouveau document Word pour chaque fichier
            doc = Document()
            
            # Ajouter une section pour l'en-tête
            header = doc.sections[0].header
            header_paragraph_left = header.paragraphs[0]
            header_run_left = header_paragraph_left.add_run()
            logo_path = r"data\logo.png"
              # Assurez-vous que le chemin du logo est correct
            header_run_left.add_picture(logo_path, width=Inches(1.5))
            header_paragraph_left.alignment = WD_PARAGRAPH_ALIGNMENT.LEFT

            # Ajouter un autre paragraphe pour le texte à droite
            header_paragraph_right = header.add_paragraph()
            header_paragraph_right.text = before_faite_text
            header_paragraph_right.alignment = WD_PARAGRAPH_ALIGNMENT.RIGHT

            # Ajouter le contenu principal dans le corps du document
            doc.add_paragraph(after_faite_text)
            doc.add_paragraph(line_20_text)
            doc.add_paragraph(line_32A_text)
            doc.add_paragraph(f"72A(50 F): {info_72A}")
            doc.add_paragraph(f"72B(59): {info_72B}")

            # Ajouter un pied de page
            footer = doc.sections[0].footer
            footer_paragraph = footer.paragraphs[0]
            footer_paragraph.text = after_message_trailer_text

            # Sauvegarder le document Word
            doc_filename = os.path.splitext(filename)[0] + ".docx"
            doc_output_path = os.path.join(output_directory, doc_filename)
            doc.save(doc_output_path)

            # Convertir le document Word en PDF
            pdf_filename = os.path.splitext(filename)[0] + ".pdf"
            pdf_output_path = os.path.join(output_directory, pdf_filename)
            try:
                output = pypandoc.convert_file(doc_output_path, 'pdf', outputfile=pdf_output_path)
                print(f"Document converti en PDF : {pdf_output_path}")
            except Exception as e:
                print(f"Erreur lors de la conversion en PDF : {e}")

            # Supprimer le fichier Word temporaire
            try:
                #os.remove(doc_output_path)
                print(f"Le fichier temporaire {doc_output_path} a été supprimé.")
            except Exception as e:
                print(f"Erreur lors de la suppression du fichier temporaire : {e}")

# Exécuter le traitement sur les fichiers PDF
process_pdfs_in_directory(pdf_directory, output_directory)

****************************************** surveillance de dossier
import os
from PyPDF2 import PdfReader
import re
from docx import Document
from docx.shared import Inches, Pt
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
import pypandoc
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import time

# Chemin du dossier contenant les fichiers PDF
pdf_directory = r"\input"

# Chemin du dossier de sortie
output_directory = r"output"

# Fonction pour extraire le texte du PDF
def extract_text_from_pdf(pdf_path):
    reader = PdfReader(pdf_path)
    text = ""
    for page in reader.pages:
        text += page.extract_text()
    return text

# Fonction pour extraire les informations avant et après "Faite nous confiance"
def extract_faite_nous_confiance(text):
    before_faite_match = re.search(r'(.*?)Faite nous confiance', text, re.DOTALL)
    if before_faite_match:
        before_faite_text = before_faite_match.group(1).strip()
    else:
        before_faite_text = "Aucune ligne trouvée avant 'Faite nous confiance'."

    after_faite_match = re.search(r'Faite nous confiance(.*?)Message Text', text, re.DOTALL)
    if after_faite_match:
        after_faite_text = after_faite_match.group(0).strip()
    else:
        after_faite_text = "Aucune ligne trouvée entre 'Faite nous confiance' et 'Message Text'."

    return before_faite_text, after_faite_text

# Fonction pour extraire les lignes 20 et 32A
def extract_lines_20_32A(text):
    line_20 = re.search(r'20:\s*Sender\'s Reference(.*?)(?=\n\d{2}[A-Z]:|$)', text, re.DOTALL)
    if line_20:
        line_20_text = line_20.group(0).strip()
    else:
        line_20_text = "Aucune ligne trouvée pour '20:'."

    line_32A = re.search(r'32A:\s*Val Dte/Curr/Interbnk Settld Amt(.*?)(?=\n\d{2}[A-Z]:|$)', text, re.DOTALL)
    if line_32A:
        line_32A_text = line_32A.group(0).strip()
    else:
        line_32A_text = "Aucune ligne trouvée pour '32A:'."

    return line_20_text, line_32A_text

# Fonction pour extraire les infos spécifiques de 72A et 72B
def extract_info_72(text):
    text_cleaned = re.sub(r'\s+', ' ', text).strip()

    match_72A = re.search(r'ORxx\s*/(.*?)\/BExx', text_cleaned)
    if match_72A:
        info_72A = match_72A.group(1).strip()
    else:
        info_72A = "Aucune information trouvée entre 'ORxx/' et '/BExx/'."

    match_72B = re.search(r"/BExx/(.*?)\/FOR", text_cleaned)
    if match_72B:
        info_72B = match_72B.group(1).strip()
    else:
        info_72B = "Aucune information trouvée entre '/BExx/' et '/FOR'."

    return info_72A, info_72B

# Fonction pour extraire les informations après 'Message Trailer'
def extract_after_message_trailer(text):
    after_message_trailer = re.search(r'(Message Trailer.*)', text, re.DOTALL)
    if after_message_trailer:
        after_message_trailer_text = after_message_trailer.group(1).strip()
    else:
        after_message_trailer_text = "Aucune ligne trouvée après 'Message Trailer'."

    return after_message_trailer_text

# Fonction principale pour traiter un fichier PDF
def process_pdf(pdf_path, output_directory):
    filename = os.path.basename(pdf_path)
    print(f"Traitement du fichier : {filename}")
    
    # Extraction du texte du fichier PDF
    text = extract_text_from_pdf(pdf_path)
    
    # Extraction des informations spécifiques
    before_faite_text, after_faite_text = extract_faite_nous_confiance(text)
    line_20_text, line_32A_text = extract_lines_20_32A(text)
    info_72A, info_72B = extract_info_72(text)
    after_message_trailer_text = extract_after_message_trailer(text)
    
    # Créer un nouveau document Word pour chaque fichier
    doc = Document()
    
    # Ajouter une section pour l'en-tête
    header = doc.sections[0].header
    header_paragraph_left = header.paragraphs[0]
    header_run_left = header_paragraph_left.add_run()
    logo_path = r"data\logo.png"
    header_run_left.add_picture(logo_path, width=Inches(1.5))
    header_paragraph_left.alignment = WD_PARAGRAPH_ALIGNMENT.LEFT

    # Ajouter un autre paragraphe pour le texte à droite
    header_paragraph_right = header.add_paragraph()
    header_paragraph_right.text = before_faite_text
    header_paragraph_right.alignment = WD_PARAGRAPH_ALIGNMENT.RIGHT

    # Ajouter le contenu principal dans le corps du document
    doc.add_paragraph(after_faite_text)
    doc.add_paragraph(line_20_text)
    doc.add_paragraph(line_32A_text)
    doc.add_paragraph(f"72A(50 F): {info_72A}")
    doc.add_paragraph(f"72B(59): {info_72B}")

    # Ajouter un pied de page
    footer = doc.sections[0].footer
    footer_paragraph = footer.paragraphs[0]
    footer_paragraph.text = after_message_trailer_text

    # Sauvegarder le document Word
    doc_filename = os.path.splitext(filename)[0] + ".docx"
    doc_output_path = os.path.join(output_directory, doc_filename)
    doc.save(doc_output_path)

    # Convertir le document Word en PDF
    pdf_filename = os.path.splitext(filename)[0] + ".pdf"
    pdf_output_path = os.path.join(output_directory, pdf_filename)
    try:
        output = pypandoc.convert_file(doc_output_path, 'pdf', outputfile=pdf_output_path)
        print(f"Document converti en PDF : {pdf_output_path}")
    except Exception as e:
        print(f"Erreur lors de la conversion en PDF : {e}")

    # Supprimer le fichier Word temporaire
    try:
        #os.remove(doc_output_path)
        print(f"Le fichier temporaire {doc_output_path} a été supprimé.")
    except Exception as e:
        print(f"Erreur lors de la suppression du fichier temporaire : {e}")

# Définir un gestionnaire d'événements pour surveiller le dossier
class NewFileHandler(FileSystemEventHandler):
    def on_created(self, event):
        if not event.is_directory and event.src_path.endswith(".pdf"):
            print(f"Nouvelle arrivée de fichier : {event.src_path}")
            process_pdf(event.src_path, output_directory)

# Initialisation de l'observateur
event_handler = NewFileHandler()
observer = Observer()
observer.schedule(event_handler, path=pdf_directory, recursive=False)

# Démarrer la surveillance
print(f"Surveillance du dossier : {pdf_directory}")
observer.start()

try:
    while True:
        time.sleep(1)  # Garder le script en fonctionnement
except KeyboardInterrupt:
    observer.stop()
    print("\nArrêt de la surveillance...")
observer.join()

__________________________________ PYCHARM 19112024
import os
from PyPDF2 import PdfReader
import re
from docx import Document
from docx.shared import Inches
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
import pypandoc
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import time

# Chemin du dossier contenant les fichiers PDF
pdf_directory = r"\input"

# Chemin du dossier de sortie
output_directory = r"\output"

# Fonction pour extraire le texte du PDF
def extract_text_from_pdf(pdf_path):
    reader = PdfReader(pdf_path)
    text = ""
    for page in reader.pages:
        text += page.extract_text()
    return text

# Fonction pour extraire les informations avant et après "Faite nous confiance"
def extract_faite_nous_confiance(text):
    before_faite_match = re.search(r'(.*?)Faite nous confiance', text, re.DOTALL)
    before_faite_text = before_faite_match.group(1).strip() if before_faite_match else "Aucune ligne trouvée avant 'Faite nous confiance'."

    after_faite_match = re.search(r'Faite nous confiance(.*?)Message Text', text, re.DOTALL)
    after_faite_text = after_faite_match.group(1).strip() if after_faite_match else "Aucune ligne trouvée entre 'Faite nous confiance' et 'Message Text'."

    return before_faite_text, after_faite_text

# Fonction pour extraire les lignes 20 et 32A
def extract_lines_20_32A(text):
    line_20 = re.search(r'20:\s*Sender\'s Reference(.*?)(?=\n\d{2}[A-Z]:|$)', text, re.DOTALL)
    line_20_text = line_20.group(0).strip() if line_20 else "Aucune ligne trouvée pour '20:'."

    line_32A = re.search(r'32A:\s*Val Dte/Curr/Interbnk Settld Amt(.*?)(?=\n\d{2}[A-Z]:|$)', text, re.DOTALL)
    line_32A_text = line_32A.group(0).strip() if line_32A else "Aucune ligne trouvée pour '32A:'."

    return line_20_text, line_32A_text

# Fonction pour extraire les infos spécifiques de 72A et 72B
def extract_info_72(text):
    text_cleaned = re.sub(r'\s+', ' ', text).strip()

    match_72A = re.search(r'ORDP\s*/(.*?)\/BENM', text_cleaned)
    info_72A = match_72A.group(1).strip() if match_72A else None

    match_72B = re.search(r"/BENM/(.*?)\/FOR", text_cleaned)
    info_72B = match_72B.group(1).strip() if match_72B else None

    return info_72A, info_72B

# Fonction pour extraire les informations après 'Message Trailer'
def extract_after_message_trailer(text):
    after_message_trailer = re.search(r'(Message Trailer.*)', text, re.DOTALL)
    return after_message_trailer.group(1).strip() if after_message_trailer else "Aucune ligne trouvée après 'Message Trailer'."

# Fonction principale pour traiter tous les fichiers PDF dans le dossier
def process_pdfs_in_directory(pdf_directory, output_directory):
    # Créer le répertoire de sortie s'il n'existe pas
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)

    # Parcourir tous les fichiers PDF dans le répertoire
    for filename in os.listdir(pdf_directory):
        if filename.endswith(".pdf"):
            base_filename = os.path.splitext(filename)[0]
            docx_path = os.path.join(output_directory, f"{base_filename}.docx")
            pdf_output_path = os.path.join(output_directory, f"{base_filename}.pdf")

            # Vérifier si le fichier existe déjà dans le dossier de sortie
            if os.path.exists(docx_path) or os.path.exists(pdf_output_path):
                print(f"Le fichier {filename} a déjà été traité. Ignoré.")
                continue

            pdf_path = os.path.join(pdf_directory, filename)
            print(f"Traitement du fichier : {filename}")
            
            # Extraction du texte du fichier PDF
            text = extract_text_from_pdf(pdf_path)
            
            # Vérifier si la ligne 72 existe dans le texte
            info_72A, info_72B = extract_info_72(text)
            if not info_72A or not info_72B:  # Si la ligne 72A ou 72B est absente
                print(f"Le fichier {filename} ne contient pas la ligne 72. Ignoré.")
                continue

            # Extraction des autres informations spécifiques
            before_faite_text, after_faite_text = extract_faite_nous_confiance(text)
            line_20_text, line_32A_text = extract_lines_20_32A(text)
            after_message_trailer_text = extract_after_message_trailer(text)
            
            # Créer un nouveau document Word
            doc = Document()
            header = doc.sections[0].header
            header_paragraph_left = header.paragraphs[0]
            header_run_left = header_paragraph_left.add_run()
            logo_path = r"\data\logo.png" # Assurez-vous que le chemin du logo est correct
            header_run_left.add_picture(logo_path, width=Inches(1.5))
            header_paragraph_left.alignment = WD_PARAGRAPH_ALIGNMENT.LEFT

            doc.add_paragraph(after_faite_text)
            doc.add_paragraph(line_20_text)
            doc.add_paragraph(line_32A_text)
            doc.add_paragraph(f"72A(50 F): {info_72A}")
            doc.add_paragraph(f"72B(59): {info_72B}")
            
            # Ajouter un pied de page
            footer = doc.sections[0].footer
            footer.paragraphs[0].text = after_message_trailer_text

            # Sauvegarder le document Word
            doc.save(docx_path)
            print("______", docx_path)

            # Convertir le document Word en PDF
            try:
                pypandoc.convert_file(docx_path, 'pdf', outputfile=pdf_output_path)
                print(f"Document converti en PDF : {pdf_output_path}")
            except Exception as e:
                print(f"Erreur lors de la conversion en PDF : {e}")
                
            # Supprimer le fichier Word temporaire
            try:
                #os.remove(docx_path)
                print(f"Le fichier temporaire {docx_path} a été supprimé.")
            except Exception as e:
                print(f"Erreur lors de la suppression du fichier temporaire : {e}")

# Classe pour gérer les événements du système de fichiers
class PDFHandler(FileSystemEventHandler):
    def on_created(self, event):
        if event.src_path.endswith('.pdf'):
            print(f" Nouveau fichier PDF détecté: {event.src_path}")
            process_pdfs_in_directory(pdf_directory, output_directory)

# Fonction pour démarrer la surveillance du répertoire
def start_monitoring(pdf_directory):
    event_handler = PDFHandler()
    observer = Observer()
    observer.schedule(event_handler, pdf_directory, recursive=False)
    observer.start()

    try:
        while True:
            time.sleep(1)  # Attendre de nouveaux événements
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

# Démarrer la surveillance
start_monitoring(pdf_directory)

------------------------------------------------
import os
from datetime import datetime
from PyPDF2 import PdfReader
import re
from docx import Document
from docx.shared import Inches
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
import pypandoc
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import time

# Fonction pour générer les chemins dynamiques
def get_dynamic_paths(base_directory):
    today = datetime.now()
    # Format des dossiers pour le mois et l'année selon votre structure (mois + année en 4 chiffres, jour en format jjmmaaaa)
    daily_folder = today.strftime("%d%m%Y")  # Exemple : 201124 pour le 20 novembre 2024
    monthly_folder = today.strftime("%m%y")   # Exemple : 1124 pour novembre 2024
    day_subfolder = os.path.join(base_directory, "swift", "data", monthly_folder, daily_folder, "entrant", "MT910", "input")
    output_subfolder = os.path.join(base_directory, "swift", "data", monthly_folder, daily_folder, "entrant", "MT910", "output")
    return day_subfolder, output_subfolder

# Fonction pour extraire le texte du PDF
def extract_text_from_pdf(pdf_path):
    reader = PdfReader(pdf_path)
    text = ""
    for page in reader.pages:
        text += page.extract_text()
    return text

# Fonction pour extraire les informations avant et après "Faite nous confiance"
def extract_faite_nous_confiance(text):
    before_faite_match = re.search(r'(.*?)Faite nous confiance', text, re.DOTALL)
    before_faite_text = before_faite_match.group(1).strip() if before_faite_match else "Aucune ligne trouvée avant 'Faite nous confiance'"

    after_faite_match = re.search(r'Faite nous confiance(.*?)Message Text', text, re.DOTALL)
    after_faite_text = after_faite_match.group(1).strip() if after_faite_match else "Aucune ligne trouvée entre 'Faite nous confiance' et 'Message Text'"

    return before_faite_text, after_faite_text

# Fonction pour extraire les lignes 20 et 32A
def extract_lines_20_32A(text):
    line_20 = re.search(r'20:\s*Sender\'s Reference(.*?)(?=\n\d{2}[A-Z]:|$)', text, re.DOTALL)
    line_20_text = line_20.group(0).strip() if line_20 else "Aucune ligne trouvée pour '20:'"

    line_32A = re.search(r'32A:\s*Val Dte/Curr/Interbnk Settld Amt(.*?)(?=\n\d{2}[A-Z]:|$)', text, re.DOTALL)
    line_32A_text = line_32A.group(0).strip() if line_32A else "Aucune ligne trouvée pour '32A:'"

    return line_20_text, line_32A_text

# Fonction pour extraire les infos spécifiques de 72A et 72B
def extract_info_72(text):
    text_cleaned = re.sub(r'\s+', ' ', text).strip()

    match_72A = re.search(r'ORDP\s*/(.*?)\/BENM', text_cleaned)
    info_72A = match_72A.group(1).strip() if match_72A else "Aucune information pour 72A"

    match_72B = re.search(r"/BENM/(.*?)\/FOR", text_cleaned)
    info_72B = match_72B.group(1).strip() if match_72B else "Aucune information pour 72B"

    return info_72A, info_72B

# Fonction pour extraire les informations après 'Message Trailer'
def extract_after_message_trailer(text):
    after_message_trailer = re.search(r'(Message Trailer.*)', text, re.DOTALL)
    return after_message_trailer.group(1).strip() if after_message_trailer else "Aucune ligne trouvée après 'Message Trailer'"

# Fonction principale pour traiter tous les fichiers PDF dans le dossier
def process_pdfs_in_directory(pdf_directory, output_directory):
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)

    for filename in os.listdir(pdf_directory):
        if filename.endswith(".pdf"):
            base_filename = os.path.splitext(filename)[0]
            docx_path = os.path.join(output_directory, f"{base_filename}.docx")
            pdf_output_path = os.path.join(output_directory, f"{base_filename}.pdf")

            # Si le fichier a déjà été traité, on l'ignore
            if os.path.exists(docx_path) or os.path.exists(pdf_output_path):
                print(f"Le fichier {filename} a déjà été traité. Ignoré.")
                continue

            pdf_path = os.path.join(pdf_directory, filename)
            print(f"Traitement du fichier : {filename}")

            text = extract_text_from_pdf(pdf_path)
            info_72A, info_72B = extract_info_72(text)
            if not info_72A or not info_72B:
                print(f"Le fichier {filename} ne contient pas la ligne 72. Ignoré.")
                continue

            before_faite_text, after_faite_text = extract_faite_nous_confiance(text)
            line_20_text, line_32A_text = extract_lines_20_32A(text)
            after_message_trailer_text = extract_after_message_trailer(text)

            doc = Document()
            header = doc.sections[0].header
            header_paragraph_left = header.paragraphs[0]
            header_run_left = header_paragraph_left.add_run()

            # Assurez-vous que ce chemin existe
            logo_path = r"\logo.png" # Ajustez ce chemin

            # Ajouter le logo dans l'en-tête
            header_run_left.add_picture(logo_path, width=Inches(1.5))
            header_paragraph_left.alignment = WD_PARAGRAPH_ALIGNMENT.LEFT

            # Ajouter le contenu du PDF dans le document Word
            doc.add_paragraph(after_faite_text)
            doc.add_paragraph(line_20_text)
            doc.add_paragraph(line_32A_text)
            doc.add_paragraph(f"72A(50 F): {info_72A}")
            doc.add_paragraph(f"72B(59): {info_72B}")

            footer = doc.sections[0].footer
            footer.paragraphs[0].text = after_message_trailer_text

            # Sauvegarder le fichier docx
            doc.save(docx_path)
            print(f"Document Word sauvegardé : {docx_path}")

            try:
                # Conversion du document Word en PDF
                pypandoc.convert_file(docx_path, 'pdf', outputfile=pdf_output_path)
                print(f"Document converti en PDF : {pdf_output_path}")
            except Exception as e:
                print(f"Erreur lors de la conversion en PDF : {e}")

# Classe pour gérer les événements du système de fichiers
class PDFHandler(FileSystemEventHandler):
    def on_created(self, event):
        if event.src_path.endswith('.pdf'):
            print(f" Nouveau fichier PDF détecté: {event.src_path}")
            pdf_directory, output_directory = get_dynamic_paths(base_directory)
            process_pdfs_in_directory(pdf_directory, output_directory)
            print("_________________________-------",pdf_directory, output_directory)

    def on_modified(self, event):
        # Pour capturer les modifications de fichiers également
        print(f"Fichier modifié : {event.src_path}")

# Fonction pour démarrer la surveillance du répertoire
def start_monitoring(base_directory):
    pdf_directory, output_directory = get_dynamic_paths(base_directory)

    # Vérification des répertoires
    if not os.path.exists(pdf_directory):
        os.makedirs(pdf_directory)
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)

    event_handler = PDFHandler()
    observer = Observer()
    observer.schedule(event_handler, pdf_directory, recursive=False)
    observer.start()

    print(f"Surveillance du répertoire {pdf_directory} démarrée...")

    try:
        while True:
            time.sleep(1)  # Attendre de nouveaux événements
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

# Démarrer la surveillance avec le répertoire de base
base_directory  = ""
start_monitoring(base_directory)


_________________________________ les trois verif

import os
from datetime import datetime
from PyPDF2 import PdfReader
import re
from docx import Document
from docx.shared import Inches
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
import pypandoc
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
import time

# Fonction pour générer les chemins dynamiques
def get_dynamic_paths(base_directory):
    today = datetime.now()
    # Format des dossiers pour le mois et l'année selon votre structure
    daily_folder = today.strftime("%d%m%Y")  # Exemple : 201124 pour le 20 novembre 2024
    monthly_folder = today.strftime("%m%y")   # Exemple : 1224 pour décembre 2024
    day_subfolder = os.path.join(base_directory, "swift", "data", monthly_folder, daily_folder, "entrant", "MT910", "input")
    output_subfolder = os.path.join(base_directory, "swift", "data", monthly_folder, daily_folder, "entrant", "MT910", "output")
    return day_subfolder, output_subfolder, monthly_folder, daily_folder

# Fonction pour extraire le texte du PDF
def extract_text_from_pdf(pdf_path):
    reader = PdfReader(pdf_path)
    text = ""
    for page in reader.pages:
        text += page.extract_text()
    return text

# Fonction pour extraire les informations avant et après "Faite nous confiance"
def extract_faite_nous_confiance(text):
    before_faite_match = re.search(r'(.*?)Faite nous confiance', text, re.DOTALL)
    before_faite_text = before_faite_match.group(1).strip() if before_faite_match else "Aucune ligne trouvée avant 'Faite nous confiance'"

    after_faite_match = re.search(r'Faite nous confiance(.*?)Message Text', text, re.DOTALL)
    after_faite_text = after_faite_match.group(1).strip() if after_faite_match else "Aucune ligne trouvée entre 'Faite nous confiance' et 'Message Text'"

    return before_faite_text, after_faite_text

# Fonction pour extraire les lignes 20 et 32A
def extract_lines_20_32A(text):
    line_20 = re.search(r'20:\s*Sender\'s Reference(.*?)(?=\n\d{2}[A-Z]:|$)', text, re.DOTALL)
    line_20_text = line_20.group(0).strip() if line_20 else "Aucune ligne trouvée pour '20:'"

    line_32A = re.search(r'32A:\s*Val Dte/Curr/Interbnk Settld Amt(.*?)(?=\n\d{2}[A-Z]:|$)', text, re.DOTALL)
    line_32A_text = line_32A.group(0).strip() if line_32A else "Aucune ligne trouvée pour '32A:'"

    return line_20_text, line_32A_text

# Fonction pour extraire les infos spécifiques de 72A et 72B
def extract_info_72(text):
    text_cleaned = re.sub(r'\s+', ' ', text).strip()

    match_72A = re.search(r'ORDP\s*/(.*?)\/BENM', text_cleaned)
    info_72A = match_72A.group(1).strip() if match_72A else "Aucune information pour 72A"

    match_72B = re.search(r"/BENM/(.*?)\/FOR", text_cleaned)
    info_72B = match_72B.group(1).strip() if match_72B else "Aucune information pour 72B"

    return info_72A, info_72B

# Fonction pour extraire les informations après 'Message Trailer'
def extract_after_message_trailer(text):
    after_message_trailer = re.search(r'(Message Trailer.*)', text, re.DOTALL)
    return after_message_trailer.group(1).strip() if after_message_trailer else "Aucune ligne trouvée après 'Message Trailer'"

# Fonction principale pour traiter tous les fichiers PDF dans le dossier
def process_pdfs_in_directory(pdf_directory, output_directory):
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)

    for filename in os.listdir(pdf_directory):
        if filename.endswith(".pdf"):
            base_filename = os.path.splitext(filename)[0]
            docx_path = os.path.join(output_directory, f"{base_filename}.docx")
            pdf_output_path = os.path.join(output_directory, f"{base_filename}.pdf")

            # Si le fichier a déjà été traité, on l'ignore
            if os.path.exists(docx_path) or os.path.exists(pdf_output_path):
                print(f"Le fichier {filename} a déjà été traité. Ignoré.")
                continue

            pdf_path = os.path.join(pdf_directory, filename)
            print(f"Traitement du fichier : {filename}")

            text = extract_text_from_pdf(pdf_path)
            info_72A, info_72B = extract_info_72(text)
            if not info_72A or not info_72B:
                print(f"Le fichier {filename} ne contient pas la ligne 72. Ignoré.")
                continue

            before_faite_text, after_faite_text = extract_faite_nous_confiance(text)
            line_20_text, line_32A_text = extract_lines_20_32A(text)
            after_message_trailer_text = extract_after_message_trailer(text)

            doc = Document()
            header = doc.sections[0].header
            header_paragraph_left = header.paragraphs[0]
            header_run_left = header_paragraph_left.add_run()

            # Assurez-vous que ce chemin existe
            logo_path = r"\logo.png" # Ajustez ce chemin

            # Ajouter le logo dans l'en-tête
            header_run_left.add_picture(logo_path, width=Inches(1.5))
            header_paragraph_left.alignment = WD_PARAGRAPH_ALIGNMENT.LEFT

            # Ajouter le contenu du PDF dans le document Word
            doc.add_paragraph(after_faite_text)
            doc.add_paragraph(line_20_text)
            doc.add_paragraph(line_32A_text)
            doc.add_paragraph(f"72A(50 F): {info_72A}")
            doc.add_paragraph(f"72B(59): {info_72B}")

            footer = doc.sections[0].footer
            footer.paragraphs[0].text = after_message_trailer_text

            # Sauvegarder le fichier docx
            doc.save(docx_path)
            print(f"Document Word sauvegardé : {docx_path}")

            try:
                # Conversion du document Word en PDF
                pypandoc.convert_file(docx_path, 'pdf', outputfile=pdf_output_path)
                print(f"Document converti en PDF : {pdf_output_path}")
            except Exception as e:
                print(f"Erreur lors de la conversion en PDF : {e}")
                
            # Supprimer le fichier Word temporaire
            try:
                #os.remove(word_output_path)
                print(f"Le fichier temporaire {docx_path} a été supprimé.")
            except Exception as e:
                print(f"Erreur lors de la suppression du fichier temporaire : {e}")

            print(f"Le document a été généré et sauvegardé sous {docx_path}")


# Classe pour gérer les événements du système de fichiers
class PDFHandler(FileSystemEventHandler):
    def on_created(self, event):
        # Surveillance des répertoires mensuels, journaliers et input
        if event.is_directory:
            print(f"Nouveau répertoire détecté : {event.src_path}")
            base_directory = r"data"
            pdf_directory, output_directory, monthly_folder, daily_folder = get_dynamic_paths(base_directory)
            
            # Vérification de la création de dossiers mensuels ou journaliers
            if os.path.basename(event.src_path) == monthly_folder:
                print(f"Nouveau dossier mensuel détecté : {monthly_folder}")
            elif os.path.basename(event.src_path) == daily_folder:
                print(f"Nouveau dossier journalier détecté : {daily_folder}")
            elif 'input' in event.src_path:
                # Surveillance des fichiers PDF dans 'input'
                print(f"Nouveau dossier 'input' détecté : {event.src_path}")
                process_pdfs_in_directory(pdf_directory, output_directory)
        elif event.src_path.endswith('.pdf'):
            print(f" Nouveau fichier PDF détecté: {event.src_path}")
            pdf_directory, output_directory, _, _ = get_dynamic_paths(base_directory)
            process_pdfs_in_directory(pdf_directory, output_directory)
            print("_________________________")

# Fonction de surveillance
def start_monitoring(base_directory):
    event_handler = PDFHandler()
    observer = Observer()
    observer.schedule(event_handler, base_directory, recursive=True)
    observer.start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
        print("Surveillance arrêtée.")
    observer.join()

# Exemple d'utilisation
base_directory = r"all chemin\data"
start_monitoring(base_directory)

___________________________ 251124
import os
from PyPDF2 import PdfReader
import re
from docx import Document
from docx.shared import Inches
from docx.enum.text import WD_PARAGRAPH_ALIGNMENT
import pypandoc

# Chemin du dossier contenant les fichiers PDF
pdf_directory = r"swift\data\1124\20112024\entrant\MT910\input"

# Chemin du dossier de sortie
output_directory = r"swift\data\1124\20112024\entrant\MT910\output"

# Fonction pour extraire le texte du PDF
def extract_text_from_pdf(pdf_path):
    reader = PdfReader(pdf_path)
    text = ""
    for page in reader.pages:
        text += page.extract_text()
    return text

# Fonction pour extraire les informations avant et après "Faite nous confiance"
def extract_faite_nous_confiance(text):
    before_faite_match = re.search(r'(.*?)Faite nous confiance', text, re.DOTALL)
    before_faite_text = before_faite_match.group(1).strip() if before_faite_match else "Aucune ligne trouvée avant 'Faite nous confiance'."

    after_faite_match = re.search(r'Faite nous confiance(.*?)Message Text', text, re.DOTALL)
    after_faite_text = after_faite_match.group(1).strip() if after_faite_match else "Aucune ligne trouvée entre 'Faite nous confiance' et 'Message Text'."

    return before_faite_text, after_faite_text

# Fonction pour extraire les lignes 20 et 32A
# Fonction pour extraire les lignes 20 et 32A
def extract_lines_20_32A(text):
    # Ligne 20: Capturer les références multi-lignes
    line_20 = re.search(r'20:\s+Sender\'s Reference\s+([\s\S]*?)\n\d{2}[A-Z]:', text)
    if line_20:
        line_20_text = f"20: Sender's Reference\n{line_20.group(1).strip()}"
    else:
        line_20_text = "Aucune ligne trouvée pour '20:'."

    # Ligne 32A: Capturer les détails de la date, devise et montant
    line_32A = re.search(
        r'32A:\s+Val Dte/Curr/Interbnk Settld Amt\s+Date\s*:\s*(.+?)\s+Currency\s*:\s*(.+?)\s+Amount\s*:\s*#(.+?)#',
        text, re.DOTALL
    )
    if line_32A:
        date, currency, amount = line_32A.groups()
        line_32A_text = f"32A: Val Dte/Curr/Interbnk Settld Amt\nDate: {date.strip()}\nCurrency: {currency.strip()}\nAmount: {amount.strip()}"
    else:
        line_32A_text = "Aucune ligne trouvée pour '32A:'."

    return line_20_text, line_32A_text


# Fonction pour extraire les infos spécifiques de 72A et 72B
def extract_info_72(text):
    text_cleaned = re.sub(r'\s+', ' ', text).strip()

    match_72A = re.search(r'ORDP\s*/(.*?)\/BENM', text_cleaned)
    info_72A = match_72A.group(1).strip() if match_72A else None

    match_72B = re.search(r"/BENM/(.*?)\/FOR", text_cleaned)
    info_72B = match_72B.group(1).strip() if match_72B else None

    return info_72A, info_72B

# Fonction pour extraire les informations après 'Message Trailer'
def extract_after_message_trailer(text):
    after_message_trailer = re.search(r'(Message Trailer.*)', text, re.DOTALL)
    return after_message_trailer.group(1).strip() if after_message_trailer else "Aucune ligne trouvée après 'Message Trailer'."

# Fonction principale pour traiter tous les fichiers PDF dans le dossier
def process_pdfs_in_directory(pdf_directory, output_directory):
    # Créer le répertoire de sortie s'il n'existe pas
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)

    # Parcourir tous les fichiers PDF dans le répertoire
    for filename in os.listdir(pdf_directory):
        if filename.endswith(".pdf"):
            base_filename = os.path.splitext(filename)[0]
            docx_path = os.path.join(output_directory, f"{base_filename}.docx")
            pdf_output_path = os.path.join(output_directory, f"{base_filename}.pdf")

            # Vérifier si le fichier existe déjà dans le dossier de sortie
            if os.path.exists(docx_path) or os.path.exists(pdf_output_path):
                print(f"Le fichier {filename} a déjà été traité. Ignoré.")
                continue

            pdf_path = os.path.join(pdf_directory, filename)
            print(f"Traitement du fichier : {filename}")
            
            # Extraction du texte du fichier PDF
            text = extract_text_from_pdf(pdf_path)
            
            # Vérifier si la ligne 72 existe dans le texte
            info_72A, info_72B = extract_info_72(text)
            if not info_72A or not info_72B:  # Si la ligne 72A ou 72B est absente
                print(f"Le fichier {filename} ne contient pas la ligne 72. Ignoré.")
                continue

            # Extraction des autres informations spécifiques
            before_faite_text, after_faite_text = extract_faite_nous_confiance(text)
            line_20_text, line_32A_text = extract_lines_20_32A(text)
            after_message_trailer_text = extract_after_message_trailer(text)
             # Affichage des résultats
    print("\nInformations avant 'Faite nous confiance':")
    print(extract_faite_nous_confiance)
    print(line_20_text)
    print(line_32A_text)
    print(f"72A(50 F): {info_72A}")
    print(f"72B(59): {info_72B}")
    print(after_message_trailer_text)



# Exécuter le traitement sur les fichiers PDF
process_pdfs_in_directory(pdf_directory, output_directory)

________________________ procedure
## Procédure de travail pour la gestion sécurisée des données à caractère personnel

### 1. Préparation et contexte
1. **Identification des données sensibles** : Avant tout traitement, il est essentiel d'identifier les données sensibles à caractère personnel.  
2. **Obtention des autorisations** : Assurez-vous d'obtenir toutes les autorisations nécessaires pour manipuler ces données, conformément aux réglementations locales, telles que le RGPD.  
3. **Protection des accès** : Les clés de chiffrement et les accès doivent être protégés et réservés aux personnes autorisées uniquement.  
4. **Environnement sécurisé** : Établissez un environnement de travail sécurisé, comprenant un réseau protégé et des permissions d'accès restreintes.

### 2. Extraction des données depuis Teradata
1. **Connexion sécurisée** : Connectez-vous à Teradata en utilisant des identifiants sécurisés.  
2. **Identification des données sensibles** : Localisez les tables ou colonnes contenant des données sensibles.  
3. **Chiffrement irréversible** : Si nécessaire, appliquez une fonction de chiffrement irréversible (hashing) sur les colonnes sensibles avant l'extraction, si les données ne nécessitent pas de déchiffrement ultérieur.  
4. **Exécution de la requête** : Exécutez la requête d'extraction en veillant à limiter la quantité de données sensibles transférées.  
5. **Transfert sécurisé** : Transférez les données extraites vers le serveur de développement en utilisant un protocole sécurisé comme SFTP ou FTPS.

### 3. Chiffrement des données sur le serveur de développement
1. **Configuration de la bibliothèque de chiffrement** : Installez ou configurez une bibliothèque de chiffrement approuvée (par exemple, `pycryptodome` pour Python).  
2. **Création d'une clé sécurisée** : Générez une clé de chiffrement sécurisée et stockez-la dans un gestionnaire de clés sécurisé (comme AWS KMS ou Azure Key Vault).  
3. **Chiffrement symétrique** : Appliquez un chiffrement symétrique (par exemple, AES-256) aux colonnes sensibles :
   - Parcourez les données sensibles.
   - Chiffrez chaque valeur avec la clé générée.
   - Remplacez les valeurs sensibles par leurs versions chiffrées.
4. **Stockage sécurisé** : Enregistrez les données chiffrées sur le serveur de développement.

### 4. Transfert vers le serveur d’homologation
1. **Transfert sécurisé** : Envoyez les données chiffrées vers le serveur d’homologation via un protocole sécurisé (SFTP, SSH).  
2. **Vérification d'intégrité** : Vérifiez l’intégrité des données transférées à l’aide de checksums ou de hash (exemple : SHA256).

### 5. Déchiffrement sur le serveur d’homologation
1. **Configuration de la bibliothèque** : Installez ou configurez la même bibliothèque de chiffrement utilisée pour le chiffrement initial.  
2. **Récupération de la clé** : Obtenez la clé de chiffrement depuis le gestionnaire de clés sécurisé.
3. **Processus de déchiffrement** :
   - Utilisez la même clé et le même algorithme que lors du chiffrement.
   - Vérifiez que les données déchiffrées correspondent aux données originales.

### 6. Bonnes pratiques et suivi
1. **Rotation des clés** : Changez régulièrement les clés de chiffrement pour réduire les risques en cas de compromission.
2. **Journalisation** : Maintenez un journal des actions effectuées sur les données sensibles (extraction, chiffrement, transfert, déchiffrement).
3. **Audit régulier** : Effectuez des audits réguliers pour garantir le respect des procédures établies.
4. **Formation continue** : Sensibilisez les équipes aux enjeux liés à la sécurité des données et à la manipulation des clés.

### 7. Gestion des incidents
1. **Procédure d'incident** : En cas de compromission des données ou des clés, déclenchez immédiatement la procédure de gestion des incidents.
2. **Notification aux autorités** : Informez les autorités compétentes si une compromission est avérée (exemple : CNIL).
3. **Mesures correctives** : Mettez en œuvre des mesures correctives pour prévenir toute récurrence d'incidents similaires.

Ce document peut être adapté selon les besoins spécifiques de votre organisation et en conformité avec les réglementations locales pertinentes concernant la protection des données personnelles [1][3][6].

Citations:
[1] https://www.cnil.fr/sites/cnil/files/atoms/files/cnil_guide_securite_personnelle.pdf
[2] https://help.qlik.com/talend/fr-FR/components/8.0/data-privacy/encrypting-and-decrypting-back-sensitive-data
[3] https://www.cnil.fr/fr/cybersecurite/securite-des-donnees
[4] https://www.oracle.com/ca-fr/security/database-security/what-is-data-security/
[5] https://help.qlik.com/talend/fr-FR/components/8.0/data-privacy/tdataencrypt
[6] https://www.autoriteprotectiondonnees.be/publications/note-relative-a-la-securite-des-donnees-a-caractere-personnel.pdf
[7] https://www.microsoft.com/fr-fr/security/business/security-101/what-is-data-protection
[8] https://rm.coe.int/t-pd-201-01-guide-pratique-sur-lutilisation-de-donnees-a-caractere-per/16807927d6
[9] https://www.talend.com/fr/resources/what-is-data-security/
[10] https://entreprendre.service-public.fr/vosdroits/F24270



-------------------------------------------------------
def extract_lines_20_32A(text):
    # Ligne 20: Transaction Reference Number
    line_20 = re.search(r'20:\s*Transaction Reference Number\s*(\w+)', text)
    if line_20:
        line_20_text = f"20:\tTransaction Reference Number\n{line_20.group(1)}"
    else:
        line_20_text = "Aucune ligne trouvée pour '20:'."

    # Ligne 32A: Val Dte/Curr/Interbnk Settld Amt
    line_32A = re.search(r'32A:\s*Val Dte/Curr/Interbnk Settld Amt\s*Date\s*:\s*(.*?)\s*Currency\s*:\s*(.*?)\s*Amount\s*:\s*#(.*?)#', text, re.DOTALL)
    if line_32A:
        line_32A_text = (
            "32A:\tVal Dte/Curr/Interbnk Settld Amt\n"
            f"Date :\t {line_32A.group(1)}\n"
            f"Currency : {line_32A.group(2)}\n"
            f"Amount : #{line_32A.group(3)}#"
        )
    else:
        line_32A_text = "Aucune ligne trouvée pour '32A:'."

    return line_20_text, line_32A_text


_______________ def extract_lines_20_32A(text):
    # Ligne 20: Transaction Reference Number
    line_20 = re.search(r'20:\s*Transaction Reference Number\s*(\w+)', text)
    if line_20:
        line_20_text = f"20:\tTransaction Reference Number\n{line_20.group(1)}"
    else:
        line_20_text = "Aucune ligne trouvée pour '20:'."

    # Ligne 32A: Val Dte/Curr/Interbnk Settld Amt
    line_32A_structured = re.search(
        r'32A:\s*Val Dte/Curr/Interbnk Settld Amt\s*Date\s*:\s*(.*?)\s*Currency\s*:\s*(.*?)\s*Amount\s*:\s*#(.*?)#',
        text,
        re.DOTALL
    )
    line_32A_simple = re.search(r'32A:\s*(\w+)', text)

    if line_32A_structured:
        line_32A_text = (
            "32A:\tVal Dte/Curr/Interbnk Settld Amt\n"
            f"Date :\t {line_32A_structured.group(1)}\n"
            f"Currency : {line_32A_structured.group(2)}\n"
            f"Amount : #{line_32A_structured.group(3)}#"
        )
    elif line_32A_simple:
        line_32A_text = f"32A:\t{line_32A_simple.group(1)}"
    else:
        line_32A_text = "Aucune ligne trouvée pour '32A:'."

    return line_20_text, line_32A_text

________________________________________________ 
from PyPDF2 import PdfReader
import re

# Fonction pour extraire le texte du PDF
def extract_text_from_pdf(pdf_path):
    reader = PdfReader(pdf_path)
    text = ""
    for page in reader.pages:
        text += page.extract_text()
    return text

# Fonction pour extraire les informations avant et après "Faite nous confiance"
def extract_faite_nous_confiance(text):
    before_faite_match = re.search(r'(.*?)Faite nous confiance', text, re.DOTALL)
    before_faite_text = before_faite_match.group(1).strip() if before_faite_match else "Aucune ligne trouvée avant 'Faite nous confiance'."

    after_faite_match = re.search(r'Faite nous confiance(.*?)Message Text', text, re.DOTALL)
    after_faite_text = after_faite_match.group(0).strip() if after_faite_match else "Aucune ligne trouvée entre 'Faite nous confiance' et 'Message Text'."

    return before_faite_text, after_faite_text

# Fonction pour extraire les lignes 20 et 32A
def extract_lines_20_and_32A(text):
    # Ligne 20
    line_20 = re.search(r'20:\s*Transaction Reference Number\s*(\w+)', text)
    if line_20:
        line_20_text = f"20:\tTransaction Reference Number\n{line_20.group(1)}"
    else:
        line_20_text = "Aucune ligne trouvée pour '20:'."

    # Ligne 32A
    match_32A_structured = re.search(
        r'32A:\s*Value Date, Currency Code\s*,\s*Amt\s*Date\s*:\s*(.*?)\s*Currency\s*:\s*(.*?)\s*Amount\s*:\s*#(.*?)#',
        text,
        re.DOTALL | re.IGNORECASE
    )
    if match_32A_structured:
        date = match_32A_structured.group(1).strip()
        currency = match_32A_structured.group(2).strip()
        amount = match_32A_structured.group(3).strip()
        line_32A_text = (
            f"32A:\tValue Date, Currency Code, Amt\n"
            f"Date :\t {date}\n"
            f"Currency : {currency}\n"
            f"Amount : #{amount}#"
        )
    else:
        # Recherche des lignes simples pour 32A
        match_32A_simple = re.search(r'32A:\s*(.*)', text, re.IGNORECASE)
        line_32A_text = f"32A:\t{match_32A_simple.group(1).strip()}" if match_32A_simple else "Aucune ligne trouvée pour '32A:'."

    return line_20_text, line_32A_text

# Fonction pour extraire les informations spécifiques de 72A et 72B
def extract_info_72(text):
    text_cleaned = re.sub(r'\s+', ' ', text).strip()

    match_72A = re.search(r'ORxx\s*/(.*?)\/BExx', text_cleaned)
    info_72A = match_72A.group(1).strip() if match_72A else "Aucune information trouvée pour 72A."

    match_72B = re.search(r"/BExx/(.*?)\/FOR", text_cleaned)
    info_72B = match_72B.group(1).strip() if match_72B else "Aucune information trouvée pour 72B."

    return info_72A, info_72B

# Fonction pour extraire les informations après "Message Trailer"
def extract_after_message_trailer(text):
    after_message_trailer = re.search(r'(Message Trailer.*)', text, re.DOTALL)
    return after_message_trailer.group(1).strip() if after_message_trailer else "Aucune ligne trouvée après 'Message Trailer'."

# Extraction du texte depuis le PDF
text = extract_text_from_pdf(pdf_path)

# Extraction des informations
before_faite_text, after_faite_text = extract_faite_nous_confiance(text)
line_20_text, line_32A_text = extract_lines_20_and_32A(text)
info_72A, info_72B = extract_info_72(text)
after_message_trailer_text = extract_after_message_trailer(text)

# Affichage des résultats
print("\nInformations avant 'Faite nous confiance':")
print(before_faite_text)
print("\nInformations après 'Faite nous confiance':")
print(after_faite_text)
print("\nInformations Ligne 20:")
print(line_20_text)
print("\nInformations Ligne 32A:")
print(line_32A_text)
print("\nInformations spécifiques 72:")
print(f"72A: {info_72A}")
print(f"72B: {info_72B}")
print("\nInformations après 'Message Trailer':")
print(after_message_trailer_text)

______________________________________________
import pandas as pd
import numpy as np

# Exemple de DataFrame
data = {
    'id': [1, 1, 2, 2, 3],
    'nom': ['Alice', 'Alice', 'Bob', 'Bob', 'Charlie'],
    'montant': [np.nan, 100, np.nan, 200, 300],
    'description': [np.nan, 'Paiement', np.nan, 'Remboursement', 'Achat'],
    'date': [np.nan, '2024-12-01', np.nan, '2024-12-02', '2024-12-03'],
    'autre_colonne1': ['val1', 'val1', 'val2', 'val2', 'val3'],
    'autre_colonne2': ['A', 'A', 'B', 'B', 'C'],
    # Ajoutez d'autres colonnes si nécessaire
}

df = pd.DataFrame(data)

# Liste des colonnes à vérifier pour les valeurs non nulles
columns_to_check = ['montant', 'description', 'date']

# Liste des colonnes pour le regroupement (toutes sauf celles à vérifier)
groupby_columns = [col for col in df.columns if col not in columns_to_check]

# Grouper par les colonnes spécifiques et combiner les données
df_cleaned = (
    df.groupby(groupby_columns, as_index=False)  # Grouper par toutes les colonnes sauf celles à vérifier
    .agg(
        {col: 'last' for col in columns_to_check}  # Garder la dernière valeur non nulle pour les colonnes importantes
    )
)

print("Avant correction :")
print(df)

print("\nAprès correction :")
print(df_cleaned)
___________________________________________________________________________

### **Roadmap Simplifiée pour le Site Web**

---

#### **1. Phase de Préparation : "La Planification"** *(Semaine 1-2)*  
- **But :** Définir les bases du projet.  
- **Étapes :**  
  - Identifier les besoins du site.  
  - Écrire le cahier des charges.  
  - Collecter les contenus (textes, images, etc.).  

🔹 **Livrable :** Cahier des charges validé.

---

#### **2. Phase de Design : "L’Apparence du Site"** *(Semaine 3-5)*  
- **But :** Créer un visuel attrayant et professionnel.  
- **Étapes :**  
  - Réaliser les maquettes des pages.  
  - Tester les maquettes pour recueillir des retours.  
  - Apporter les ajustements nécessaires.  

🔹 **Livrable :** Design validé.

---

#### **3. Phase de Développement Backend : "L’Ingénierie Technique"** *(Semaine 6-8)*  
- **But :** Mettre en place la structure interne du site.  
- **Étapes :**  
  - Construire la base de données pour gérer les informations.  
  - Créer les systèmes pour les contenus dynamiques (comme les sous-menus).  
  - Tester les fonctionnalités internes.  

🔹 **Livrable :** Backend opérationnel.

---

#### **4. Phase de Développement Frontend : "Le Visuel du Site"** *(Semaine 9-11)*  
- **But :** Construire l’interface que les visiteurs utiliseront.  
- **Étapes :**  
  - Intégrer les maquettes au site (menus et sous-menus).  
  - Connecter le site au backend pour afficher des données en direct.  
  - Ajouter des animations et tester l’utilisation.  

🔹 **Livrable :** Frontend interactif et prêt à l’emploi.

---

#### **5. Phase Partie Admin : "Le Tableau de Bord"** *(Semaine 12-13)*  
- **But :** Faciliter la gestion du site par l’équipe.  
- **Étapes :**  
  - Créer une interface pour gérer les contenus (ajouter, modifier, supprimer).  
  - Ajouter un système pour lire les messages du formulaire de contact.  
  - Tester la facilité d’utilisation.  

🔹 **Livrable :** Tableau de bord fonctionnel.

---

#### **6. Phase Tests et Corrections : "La Dernière Révision"** *(Semaine 14-15)*  
- **But :** S’assurer que tout fonctionne bien.  
- **Étapes :**  
  - Vérifier que toutes les fonctionnalités sont opérationnelles.  
  - Tester les performances du site (vitesse, compatibilité mobile).  
  - Réaliser des ajustements selon les retours.  

🔹 **Livrable :** Site validé et prêt pour le déploiement.

---

#### **7. Phase Déploiement : "La Mise en Ligne"** *(Semaine 16)*  
- **But :** Rendre le site accessible au public.  
- **Étapes :**  
  - Installer le site sur un hébergement sécurisé.  
  - Mettre en place le certificat SSL pour la sécurité.  
  - Vérifier que tout est en ordre une dernière fois.  

🔹 **Livrable :** Site en ligne.

---

#### **8. Phase Maintenance : "L’Entretien Continu"** *(Continu)*  
- **But :** Garder le site à jour et fonctionnel.  
- **Étapes :**  
  - Corriger les éventuels problèmes.  
  - Mettre à jour les contenus régulièrement.  
  - Écouter les retours des utilisateurs pour améliorer l’expérience.  

🔹 **Livrable :** Site stable et amélioré au fil du temps.

---

### **Conseils pour la Présentation Visuelle**
1. **Utilisez Miro :**
   - Créez une frise chronologique horizontale.
   - Ajoutez des couleurs pour chaque phase (par exemple : bleu pour la préparation, vert pour les tests, orange pour le développement).
   - Intégrez des icônes simples (🎨 pour le design, 💻 pour le développement, 🚀 pour le déploiement).

2. **Simplifiez encore plus :**
   - Assurez-vous que chaque étape est claire et rapide à comprendre.
   - Ajoutez des commentaires collaboratifs si vous travaillez en équipe. 

Avec cette roadmap, tout le monde comprendra les étapes essentielles du projet et leur rôle dans le succès du site web.


))))))))))))))))))))))))))))))
### Roadmap Simplifiée pour le Développement du Site Web Dynamique

#### **1. Création de la Base de Données (Semaine 1)**  
- **Objectif** : Concevoir une base de données pour gérer les contenus dynamiques.  
- **Étapes clés** :  
  - Identifier les données nécessaires : pages, sous-menus, contacts, utilisateurs, projets, médiathèque, webinaires, idéation, etc.  
  - Créer des tables pour chaque entité principale (ex. : `users`, `services`, `events`, `projects`).  
- **Livrable** : Une base de données structurée, prête à être utilisée par le site.  

---

#### **2. Développement du Back-End (Semaine 2-3)**  
- **Objectif** : Mettre en place le système back-end pour gérer les données et alimenter les fonctionnalités dynamiques.  
- **Étapes clés** :  
  - Développer une API pour gérer les contenus (CRUD).  
  - Implémenter l’authentification des utilisateurs (administrateurs).  
  - Connecter la base de données au back-end.  
- **Livrable** : Un back-end opérationnel et prêt pour l’intégration avec le front-end.  

---

#### **3. Développement du Front-End (Semaine 4-5)**  
- **Objectif** : Concevoir une interface visuelle et interactive pour les visiteurs.  
- **Étapes clés** :  
  - Intégrer les maquettes pour les menus, sous-menus, et pages vitrines.  
  - Connecter les pages au back-end pour afficher les contenus dynamiques.  
  - Ajouter des animations et optimiser l’expérience utilisateur (responsive design).  
- **Livrable** : Un front-end interactif et fonctionnel.  

---

#### **4. Création de l’Espace Administrateur (Semaine 6)**  
- **Objectif** : Permettre aux administrateurs de gérer les contenus et interagir avec les visiteurs.  
- **Étapes clés** :  
  - Concevoir un tableau de bord pour gérer les contenus (ajout, modification, suppression).  
  - Intégrer une fonctionnalité pour lire les messages du formulaire de contact/idéation.  
  - Tester la simplicité et l’efficacité de l’interface admin.  
- **Livrable** : Une interface d’administration intuitive et sécurisée.  

---

#### **5. Tests et Optimisations (Semaine 7)**  
- **Objectif** : Vérifier la stabilité et les performances du site.  
- **Étapes clés** :  
  - Tester les fonctionnalités (navigation, affichage, gestion de contenu).  
  - Optimiser les performances (vitesse de chargement, compatibilité mobile).  
  - Apporter des corrections selon les retours d’expérience.  
- **Livrable** : Un site fiable, validé et prêt pour le déploiement.  

---

#### **6. Déploiement et Maintenance (Semaine 8 et après)**  
- **Objectif** : Assurer la mise en ligne et la pérennité du site.  
- **Étapes clés** :  
  - Déployer le site sur un serveur (avec nom de domaine et certificat SSL).  
  - Mettre en place un plan de maintenance pour corriger les bugs et ajouter de nouvelles fonctionnalités.  
  - Collecter les retours utilisateurs pour améliorer l’expérience.  
- **Livrable** : Un site stable, accessible, et régulièrement mis à jour.  

--- 

### Résumé des Phases et Livrables  
| **Phase**               | **Objectif**                              | **Livrable**                           |  
|--------------------------|-------------------------------------------|----------------------------------------|  
| Création de la BDD       | Structurer les données                   | Base de données prête                 |  
| Développement Back-End   | Gérer les contenus dynamiques            | API et back-end fonctionnels          |  
| Développement Front-End  | Interface utilisateur                    | Pages dynamiques et responsives       |  
| Création Espace Admin    | Gestion des contenus                     | Tableau de bord intuitif              |  
| Tests et Optimisations   | Vérifier et améliorer                    | Site validé et performant             |  
| Déploiement et Maintenance | Mise en ligne et amélioration continue | Site en production et optimisé        |  
